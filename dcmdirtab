#!/usr/bin/env perl
package BIDS;
use strict;
use feature 'signatures';
no warnings 'experimental::signatures';
use Carp;

my %mode_folder = (dwi=>'dwi',
   T1w=>'anat', T2w=>'anat',
   bold=>'func', sbref=>'func',
   'magnitude'=>'fmap', 'magnitude1'=>'fmap', 'magnitude2'=>'fmap',
   'phase'=>'fmap', 'phase1'=>'fmap', 'phase2'=>'fmap', 'phasediff'=>'fmap');
my @attributes_ordered = qw/task acq ce dir rec run echo mode/;

sub combine_attr($attr, $val){
   # mode (T1w, bold, dwi, ...) is by itself at the end of the file name
   # all others are e.g. run-1, acq-label
   return $attr eq "mode" ? $val : "$attr-$val" if $val;
   return "";
}

sub new($class, %opts){
   # to build out a bids, the very minimum info is subject and mode
   # and if mode == "task" we also need a task name
   my @req = qw/mode subj/;
   push @req, "task" if $opts{mode} eq "bold";

   for my $req (@req){
      croak "BIDS: must have '$req'" if not $opts{$req};
   }
   croak "BIDS: bad mode '$opts{mode}'! not in @{[keys(%mode_folder)]}"
     if not $mode_folder{$opts{mode}};

   for my $attr (keys(%opts)){
      next if $attr =~ /^(mode|ses|subj)$/;
      croak "BIDS: bad attribute '$attr' not in @attributes_ordered"
        if not grep(/^$attr$/, @attributes_ordered);
   }
   my $self = \%opts;
   bless $self, $class;
   return $self;
}

sub path($self, $ext=".nii.gz") {
   # use BIDS object's subj and ses if they are provided
   my $subj=$self->{subj};
   my $ses =$self->{ses};
   my $prefix="sub-$subj/$mode_folder{$self->{mode}}/sub-${subj}_";
   $prefix = "sub-$subj/$mode_folder{$self->{mode}}/ses-$ses/sub-${subj}_ses-${ses}_" if $ses;
   
   my $file = join "_",
      grep {!/^-?$/}
      map {combine_attr($_, $self->{$_})} @attributes_ordered; 
   return "${prefix}$file$ext";
}

package criteria;
use strict;
use feature 'signatures';
no warnings 'experimental::signatures';

sub new($class, %opts){
#      (n_expect => 1,
#       bids => {mode=>"T1w"},
#       matches => { pname => qr/mprage/, ndcm => 176,}),
   $opts{n_expect} ||= 1;
   for my $req (qw/bids matches/){
       croak ("criteria: must have '$req' given ". join(", ", keys(%opts))) unless $opts{$req};
   }
   my %subset = %opts{qw/n_expect bids matches/};
   my $self = \%subset;
   bless $self, $class;
}

sub match_seq($self, $seq) {
   my $tests = $self->{matches};
   my $does_match = 0;
   #print "test: ", Dumper($tests), "\n";
   #print "seq ", Dumper($seq), "\n";
   for my $col (keys(%$tests)){
      #print "# comparing $col: $seq->{$col} ?=? $tests->{$col}\n";
      if($seq->{$col} =~ /$tests->{$col}/){
         $does_match = 1;
      } else {
         return 0;
      }
   }
   return $does_match;
}

package heuristic;
use strict;
use feature 'signatures';
no warnings 'experimental::signatures';

use File::Basename;
use Data::Dumper;
sub dcm2niix_cmd($nii_out, $dcm_folder){
   my $outdir = dirname($nii_out);
   my $outname = basename($nii_out, ".nii.gz");
   return "niinote $nii_out dcm2niix -b -f $outname -o $outdir $dcm_folder";
}

sub session_cmds($sequences, @criteria){
   # filter sequences to those with properties matching heuristic criteria
   # return dcm2niix command to generate bids
   # check criteria for every session so we can enumerate matches (into run#s)

   #print "ses: ", Dumper($sequences), "\n";
   my %matches = ();
   for my $crt (@criteria) {
      my $run = 1;
      for my $seq (@$sequences) {
         #print "seq: ", Dumper($seq), "\n";
        next unless $crt->match_seq($seq);

        ++$run if $crt->{n_expect} != 1;

        my $nii_out;
        if(ref($crt->{bids}) eq "CODE") {
          $nii_out = $crt->{bids}->($seq, $run);
        } else {
          # will pass run=>$run along with seq info
          # ses will only be passed if it exists
          my @runs=$run?("run" => $run):();
          $nii_out = BIDS->new(%{$crt->{bids}}, @runs, %{$seq}{qw/subj ses/})->path();
        }


        my $cmd = dcm2niix_cmd($nii_out, $seq->{fullpath});

        # using hash so we only write out a file once. later we use values(%results)
        # this then always takes the last sequence if n_expected == 1
        #
        # maybe we want to keep a list of what we are replacing?
        # push @{$matches{$nii_out}}, $cmd;
        $matches{$nii_out}=$cmd;
      }
   }

   return %matches;
}
sub mk_criteria(@criteria){
   my @c = map {criteria->new(%$_)} @criteria;
   return @c;
}

sub parse($sequences, $criteria){
   my @criteria = mk_criteria(@$criteria);
   my %cmds = session_cmds($sequences, @criteria);
   #print "cmds: ",Dumper(%cmds), "\n";
   return values(%cmds);
}
1;

package dcmdirtab;
use v5.28;
use strict; use warnings; use autodie; 
use feature qw/signatures/; no warnings qw(experimental::signatures);
use File::Slurp; # read_file
use Getopt::Long;
use Pod::Usage;
use Data::Dumper;
use File::Basename;
use File::Glob ":bsd_glob";
use Carp;
# glob is now bsd_glob. default glob doesn't handle spaces

my $sep="\t";
my $DEBUG=0;

my %opts=(subpat=>'\d+', help=>0);
GetOptions(\%opts, 'subpat|s=s', 'ses|b=s', 'cols|c=s', 'dirs|d=s@', 'config|c=s', 'eval|e=s', 'help|?', 'no-header|H') or pod2usage(2);
# TODO: implmement --ses --cols
pod2usage(1) if $opts{help};

my %conf=();
$conf{subpat} = qr/$opts{subpat}/;
$conf{dcmpat} = '.*MR.*\|.*dcm$';
# default file info things to grab

$conf{columns}={
   subj   => sub($p) {return($p=~m/$conf{subpat}/?$&:"NOSUBJ");},
   ndcm   => sub($p) {my @D=split /\n/, `find -L "$p" -maxdepth 2 -regextype sed -iregex '$conf{dcmpat}' -type f,l`;return($#D +1);},
   dname  => sub($p) {return basename($p);},
   fullpath  => sub($p) {return $p},
   # use afni's dicom_hdr. need tag ids.
   "seqno" => "0020,0011",
   "tr"    => "0018,0080",
   "matrix"=> "0018,1310",
   "dir"   => "0018,1312",
   "dir2"  => "0051,100e",
   "pname" => "0018,1030" 
};
$conf{col_order} = [qw/subj ndcm dname seqno tr matrix dir pname/];

# if falsey, dont convert
# $conf{convert} = sub convert { return("") };

# overload with other things
# TODO: test isfile, test exists convert
#      while at it, test each tag_order  in tags
if(exists $opts{config}){
   eval read_file($opts{config}) or croak "config eval failed $@ $!";
}
if($opts{eval}){
   eval "$opts{eval}" or croak "custom eval code failed! $@ $!";
}

# initialize before looping
my @all=();
pod2usage(1) if $#{$opts{dirs}} <0;

# break columns into tags (strings in hash) and path functions ("CODE")
# CODE get passed in file name. others used as tag ids
my @all_cols = @{$conf{'col_order'}};
my @path_cols = grep {ref($conf{'columns'}->{$_}) eq 'CODE'} @all_cols;
my @tag_cols  = grep {ref($conf{'columns'}->{$_}) eq ''    } @all_cols;
my $cmd_tags = join " ", map {"-tag ". $conf{columns}->{$_} ." "} @tag_cols;

sub first_dcm_info($d){
    # use dicom_hinfo to get tag_order (via cmd_tags)
    # N.B. globals '$sep' and '$cmd_tags'
    my $first_dcm_cmd = qq/
      find -L "$d" -maxdepth 2 -type f,l -regextype sed -iregex '$conf{dcmpat}' -print0 -quit |
      xargs -0rI{} dicom_hinfo -full_entry -no_name -sepstr '$sep' $cmd_tags "{}"/;
    print "$first_dcm_cmd\n" if $DEBUG>=2;
    chomp(my $out = qx/$first_dcm_cmd/);
    return(split /$sep/, $out);
}

# header: double negative to make providing options easy + default to header
say join $sep, @all_cols if not $opts{'no-header'};

# could give many globs. expand all
foreach my $optd (@{$opts{dirs}}) {
 foreach my $d (glob("$optd"))  {
    print("d: $d; @path_cols};\n") if $DEBUG>2;

    my %acq = ();

    @acq{@path_cols} = map {$conf{columns}->{$_}->($d)} @path_cols;
    @acq{@tag_cols}  = first_dcm_info($d);

    #my $ses = $d=~m/$sespat/?$&:"NOSES";
    print join($sep, map {$_=$_?$_:""} @acq{@all_cols}), "\n";

    # presumably run dcm2niix given info from this dcm
    # would be set in -e or -c file.pm (untested!)
    $conf{run}->(%acq) if($conf{run});

    push @all, \%acq;
    print Dumper(\%acq),"\n" if $DEBUG>2;
 }
}
print Dumper(@all),"\n" if $DEBUG>2;

__END__
=head1 NAME

dcminfo - get dicom info

=head1 SYNOPSIS

Options:

=over 4

=item -s --subpat:
regexp describes how to find subjects

=item -d --dirs:
dir glob pattern to dicom folders. e.g. C</path/1*_2*/*/*/>
mulitple C<-d '/path/*/'> accepted

=item -c --config:
path to config script. e.g. C<config.pl>.

see L<CONFIG> in C<perldoc $(which dcminfo)>

=item -e --eval:
inline perl code. useful for quick modifications.
For example, to add a column to the output:

   -e 'push @{$conf{col_order}}, "dir2"'

To add a new function and use it

   -e '$conf{columns}->{ses} = sub($p){return  $p=~/Time (\d|Rescan)/i?$1:0}; push @{$conf{col_order}}, "ses"'

Quick debugging

   -e 'say Dumper(\%conf); exit'

=item -h --help:
this message

=back

Example:

   # find subjects like E07 with config /tmp/test.pm
   dcminfo -s 'E\d+' -d '/Volumes/L/bea_res/Data/EpilepsyMR/epilepsy_bold/E07/E07_MR3/scans/*/' -c /tmp/test.pm 



=head1 CONFIG

conf is a hash with keys

=over 4


=item subpat    - same as -s. config wins if both provided

=item col_order - order of output columns (array ref)

=item columns - hash ref of afni dcminfo colname=>'xxxx,yyyy' or colname=>sub($path){} path function

=back

=head2 Default

    $conf{columns}={
       "seqno" =>"0020,0011",
       "tr"    =>"0018,0080",
       "matrix"=>"0018,1310",
       "pname" =>"0018,1030" 
       "subj" => sub($p){return($p=~m/$conf{subpat}/?$&:"NOSUBJ");},
       "ndcm" => sub($p){return(split /\n/, `find -L "$p" -maxdepth 2 -type f,l` +1);}
    };
       

=head1 NOTES

 use look ahead in patterns. to match 3 digits that start a directory name
    -s '(?<=/)\d{3}' 


=cut

=head1 Testing
pathalogical commitment to a single file
use Perl::RunEND's C<perl-run-end>
=cut

require 'dcmdirtab';
# in iperl, reply, or pdl2: Module::Refresh->refresh
use Data::Dumper;
use Test2::V0;
is(BIDS::combine_attr("anything",""), "", "combine_attr empty");
is(BIDS::combine_attr("run","1"), "run-1", "combine_attr normal");
is(BIDS::combine_attr("mode","bold"), "bold", "combine_attr mode");
my $sequences = [{subj=>1, pname=>"rest",  ndcm=>180,fullpath=>'xxx/yyyy'  },
                {subj=>2, pname=>"rest",ndcm=>76, fullpath=>'bad_rest'},
                {subj=>3, pname=>"mprage",ndcm=>176,fullpath=>'y/x'       }];

my %c=(n_expect=>1, matches=>{pname => qr/rest/, ndcm=>180}, bids=>{mode=>"bold",task=>"rest"});
my $crt = criteria->new(%c);
ok criteria->new(%c), "make criteria";
is $crt->match_seq($sequences->[0]), 1, "heuristic match (rest)";
is $crt->match_seq($sequences->[1]), 0, "heuristic no match (bad rest)";
is $crt->match_seq($sequences->[2]), 0, "heuristic no match (mprage)";
ok heuristic::session_cmds($sequences, $crt), "generic sequences cmds";
ok heuristic::parse($sequences,[$crt]), "generic parse";
my @res = heuristic::parse($sequences,[$crt]);
is @res, 1, "parse returns only one";
ok $res[0] =~ m:dcm2niix.*sub-1/.*func xxx/yyyy:, "is sub-1 rest xxx/yyyy";

$c{bids} = sub {return "./nonsense.nii.gz"};
my $crtf = criteria->new(%c);
@res = heuristic::parse($sequences,[$crtf]);
ok $res[0] =~ m/dcm2niix.*nonsense/, "use bids function instead of template";
done_testing;
